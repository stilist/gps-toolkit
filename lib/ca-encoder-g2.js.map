{"version":3,"sources":["../src/ca-encoder-g2.js"],"names":[],"mappings":"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","file":"ca-encoder-g2.js","sourcesContent":["import 'babel-polyfill'\nimport FibonacciLFSR from './fibonacci-lfsr'\nimport population_count from './utilities/population-count'\n\n/**\n * Taken from the GPS specification, Table 3-Ia.\n *\n * @access private\n *\n * @see http://www.gps.gov/technical/icwg/IS-GPS-200H.pdf\n */\nconst sv_delay_taps = Object.freeze([\n  null,\n  [2, 6],\n  [3, 7],\n  [4, 8],\n  [5, 9],\n  [1, 9],\n  [2, 10],\n  [1, 8],\n  [2, 9],\n  [3, 10],\n  [2, 3], // 10\n  [3, 4],\n  [5, 6],\n  [6, 7],\n  [7, 8],\n  [8, 9],\n  [9, 10],\n  [1, 4],\n  [2, 5],\n  [3, 6],\n  [4, 7], // 20\n  [5, 8],\n  [6, 9],\n  [1, 3],\n  [4, 6],\n  [5, 7],\n  [6, 8],\n  [7, 9],\n  [8, 10],\n  [1, 6],\n  [2, 7], // 30\n  [3, 8],\n  [4, 9]\n])\n\n/**\n * Generates the *G2* {@linkcode LFSR} for the [C/A-Code]{@linkcode CAEncoder}\n * (coarse acquisition code) *G<sub>i</sub>* [Gold code]. The *G2* LFSR\n * operates like a normal LFSR, but it meant to be used at a cycle delay. The\n * delay can be done two ways:\n *\n * * compute the sequence and move `n` bits from the end of the sequence to the\n *   front, or\n * * XOR the state with a second set of taps.\n *\n * [GPS specification]{@link http://www.gps.gov/technical/icwg/IS-GPS-200H.pdf}\n * (IS-GPS-200 revision H) ยง 3.2.1.3\n *\n * > The *G2<sub>i</sub>* sequence is a *G2* sequence selectively delayed by\n * > pre-assigned number of chips, thereby generating a set of different\n * > C/A-codes.\n *\n * ยง 3.3.2.1\n *\n * > The [*G2<sub>i</sub>*] sequence is selectively delayed by an integer\n * > number of chips to produce many different *G(t)* patterns (defined in\n * > Tables 3-Ia and 3-Ib).\n *\n * ยง 3.3.2.3\n *\n * > The *G2<sub>i</sub>* sequence is formed by effectively delaying the *G2*\n * > sequence by an integer number of chips. The *G1* and *G2* sequences are\n * > generated by 10-stage shift registers having the following polynomials as\n * > referred to in the shift register input (see Figures 3-8 and 3-9).\n * >\n * > * G1 = X<sup>10</sup> + X<sup>3</sup> + 1, and\n * > * G2 = X<sup>10</sup> + X<sup>9</sup> + X<sup>8</sup> + X<sup>6</sup> + X<sup>3</sup> + X<sup>2</sup> + 1.\n * >\n * > The initialization vector for the *G1* and *G2* sequences is `1111111111`.\n * > The *G1* and *G2* shift registers are initialized at the P-coder *X1*\n * > epoch. The *G1* and *G2* registers are clocked at 1.023 MHz derived from\n * > the 10.23 MHz P-coder clock. [...]\n * >\n * > The effective delay of the *G2* sequence to form the *G2<sub>i</sub>*\n * > sequence may be accomplished by combining the output of two stages of the\n * > *G2* shift register by modulo-2 addition (see Figure 3-10). However, this\n * > two-tap coder implementation generates only a limited set of valid C/A\n * > codes.\n *\n * @augments FibonacciLFSR\n *\n * @see http://what-when-how.com/a-software-defined-gps-and-galileo-receiver/gps-signal-gps-and-galileo-receiver-part-2/\n */\nclass CAEncoderG2 extends FibonacciLFSR {\n  /**\n   * @param {number} sv - The SV ID.\n   *\n   * @throws {TypeError}\n   */\n  constructor(sv) {\n    super(10, [10, 2, 3, 6, 8, 9], 0b1111111111)\n\n    if (!Number.isInteger(sv)) throw new TypeError('sv must be a number')\n    if (sv < 1 || sv > 32) throw new TypeError('sv must be in the range 1..32 (inclusive)')\n    this.sv = sv\n  }\n\n  /**\n   * The delay taps as a bitmask.\n   *\n   * @access private\n   * @type {number}\n   */\n  get delay_taps() {\n    if (this._delay_taps) return this._delay_taps\n\n    const taps = sv_delay_taps[this.sv]\n\n    // `1 << tap_j - 1` makes a one followed by `tap_j - 1` zeroes; that value\n    // is then ORed with `mask`, which sets bit `tap_j - 1` of `mask` to `1`.\n    this._delay_taps = taps.map((tap_j) => this.m - tap_j).\n                            reduce((memo, tap_j) => memo | (1 << tap_j - 1),\n                                   0)\n\n    return this._delay_taps\n  }\n\n  /**\n   * Generate the next state in the sequence.\n   *\n   * @returns {number} The output bit.\n   */\n  next() {\n    super.next()\n\n    return this.delay_bit\n  }\n\n  /**\n   * Calculate the delayed output bit using {@link CAEncoderG2.delay_taps}.\n   *\n   * @access private\n   * @type {number}\n   */\n  get delay_bit() {\n    const active_delay_bits = this.current_state & this.delay_taps\n    const active_delay_bit_count = population_count(active_delay_bits)\n    const output_bit = active_delay_bit_count % 2\n\n    return output_bit\n  }\n\n  /**\n   * @inheritdoc\n   */\n  get sequence() {\n    if (this._sequence) return this._sequence\n\n    const bits = [this.seed & 0b1]\n    for (let i = 0; ; i++) {\n      let bit = this.next()\n\n      if (this.current_state === this.seed) break\n      else bits.push(bit)\n    }\n\n    this._sequence = parseInt(bits.join(''), 2)\n\n    return this._sequence\n  }\n}\nexport default CAEncoderG2\n"]}
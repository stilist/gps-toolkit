{"version":3,"sources":["../src/gold-code.js"],"names":[],"mappings":";;;;;;;;;;AAAA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;IAmBM,Q;;;;;;;;;;;;AAWJ,oBAAY,CAAZ,EAAe,eAAf,EAAgC,eAAhC,EAAiD,KAAjD,EAAwD;AAAA;;AACtD,SAAK,IAAL,GAAY,CAAZ;AACA,SAAK,eAAL,GAAuB,eAAvB;AACA,SAAK,eAAL,GAAuB,eAAvB;AACA,SAAK,KAAL,GAAa,KAAb;AACD;;;;;;;;;;;;;;;;;;;2BAyEM;AACL,WAAK,KAAL,CACE,OADF,CACU;AAAA,eAAQ,KAAK,IAAL,EAAR;AAAA,OADV;;AAGA,aAAO,KAAK,UAAZ;AACD;;;wBAtEW;AACV,UAAI,KAAK,MAAT,EAAiB,OAAO,KAAK,MAAZ;;AAEjB,UAAM,QAAQ,4BAAkB,KAAK,IAAvB,EAA6B,KAAK,eAAlC,EAAmD,CAAnD,CAAd;AACA,UAAM,QAAQ,4BAAkB,KAAK,IAAvB,EAA6B,KAAK,eAAlC,EAAmD,KAAK,KAAxD,CAAd;;AAEA,WAAK,MAAL,GAAc,CAAC,KAAD,EAAQ,KAAR,CAAd;;AAEA,aAAO,KAAK,MAAZ;AACD;;;;;;;;;;wBAOY;AACX,UAAI,KAAK,OAAT,EAAkB,OAAO,KAAK,OAAZ;;AAElB,WAAK,OAAL,GAAe,KAAK,KAAL,CAAW,CAAX,EACb,uBADF;;AAGA,aAAO,KAAK,OAAZ;AACD;;;;;;;;;;wBAOc;AACb,UAAI,KAAK,SAAT,EAAoB,OAAO,KAAK,SAAZ;;AAEpB,UAAM,QAAQ,KAAK,KAAL,CAAW,CAAX,CAAd;;;AAGA,UAAM,OAAO,CAAC,KAAK,UAAN,CAAb;AACA,aAAO,IAAP,EAAa;AACX,YAAI,MAAM,KAAK,IAAL,EAAV;;AAEA,YAAI,MAAM,aAAN,KAAwB,MAAM,IAAlC,EAAwC,MAAxC,KACK,KAAK,IAAL,CAAU,GAAV;AACN;;AAED,WAAK,SAAL,GAAiB,SAAS,KAAK,IAAL,CAAU,EAAV,CAAT,EAAwB,CAAxB,CAAjB;;AAEA,aAAO,KAAK,SAAZ;AACD;;;;;;;;;;wBAOgB;AAAA,kCACQ,KAAK,KADb;;AAAA,UACR,KADQ;AAAA,UACD,KADC;;;AAGf,aAAO,MAAM,UAAN,GAAmB,MAAM,UAAhC;AACD;;;;;;kBAeY,Q","file":"gold-code.js","sourcesContent":["import 'babel-polyfill'\n\nimport FibonacciLFSR from './fibonacci-lfsr'\n\n/**\n * Implements a Gold code generator.\n *\n * @augments FibonacciLFSR\n *\n * @example <caption>A Gold code of size 5</caption>\n *   var gold_code = new GoldCode(5, [5, 2, 3, 4], [5, 3], 0b10)\n *   gold_code.next()\n *   //=> 1\n *   gold_code.sequence\n *   //=> 0b1100011111110001000111100010100\n *   gold_code.length\n *   //=> 24\n *\n * @see https://en.wikipedia.org/wiki/Gold_code\n * @see http://pages.hmc.edu/harris/class/e11/lect7.pdf\n */\nclass GoldCode {\n  /**\n   * @param {number} m - Number of taps in the register.\n   * @param {number[]} [feedback_taps_a] - Indices of taps that affect the\n   *   output (range `1..m` inclusive).\n   * @param {number[]} [feedback_taps_b] - Indices of taps that affect the\n   *   output (range `1..m` inclusive).\n   * @param {(number|string)} [seedB=1] - Starting value for the second LFSR.\n   *\n   * @throws {TypeError}\n   */\n  constructor(m, feedback_taps_a, feedback_taps_b, seedB) {\n    this.size = m\n    this.feedback_taps_a = feedback_taps_a\n    this.feedback_taps_b = feedback_taps_b\n    this.seedB = seedB\n  }\n\n  /**\n   * Gold codes are generated from a pair of {@link LFSR}s.\n   *\n   * @access protected\n   * @type {FibonacciLFSR[]}\n   */\n  get lfsrs() {\n    if (this._lfsrs) return this._lfsrs\n\n    const lfsrA = new FibonacciLFSR(this.size, this.feedback_taps_a, 0b1)\n    const lfsrB = new FibonacciLFSR(this.size, this.feedback_taps_b, this.seedB)\n\n    this._lfsrs = [lfsrA, lfsrB]\n\n    return this._lfsrs\n  }\n\n  /**\n   * The length of the Gold code sequence.\n   *\n   * @type {number}\n   */\n  get length() {\n    if (this._length) return this._length\n\n    this._length = this.lfsrs[0].\n      maximum_sequence_length\n\n    return this._length\n  }\n\n  /**\n   * The complete Gold code sequence.\n   *\n   * @type {number}\n   */\n  get sequence() {\n    if (this._sequence) return this._sequence\n\n    const lfsrB = this.lfsrs[1]\n\n    // (lfsrA.current_state & 1)\n    const bits = [this.output_bit]\n    while (true) {\n      let bit = this.next()\n\n      if (lfsrB.current_state === lfsrB.seed) break\n      else bits.push(bit)\n    }\n\n    this._sequence = parseInt(bits.join(''), 2)\n\n    return this._sequence\n  }\n\n  /**\n   * The current output bit.\n   *\n   * @type {number}\n   */\n  get output_bit() {\n    const [lfsrA, lfsrB] = this.lfsrs\n\n    return lfsrA.output_bit ^ lfsrB.output_bit\n  }\n\n  /**\n   * Generate the next state in the sequence.\n   *\n   * @returns {number} The output bit.\n   */\n  next() {\n    this.lfsrs.\n      forEach(lfsr => lfsr.next())\n\n    return this.output_bit\n  }\n}\n\nexport default GoldCode\n"]}
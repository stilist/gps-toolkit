{"version":3,"sources":["../src/fibonacci-lfsr.js"],"names":[],"mappings":";;;;;;;;;;AAAA;;AACA;;;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAqCM,a;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2BA6BG;AACL,UAAI,QAAQ,KAAK,aAAjB;;;AAGA,UAAI,qBAAqB,QAAQ,KAAK,iBAAtC;AACA,UAAI,mBAAmB,+BAAiB,kBAAjB,CAAvB;AACA,UAAI,YAAY,mBAAmB,CAAnC;;;AAGA,gBAAU,CAAV;;;;AAIA,eAAU,aAAc,KAAK,CAAL,GAAS,CAAjC;;AAEA,WAAK,aAAL,GAAqB,KAArB;;AAEA,aAAO,KAAK,UAAZ;AACD;;;;;;;;;;wBAO6B;AAAA;;AAC5B,UAAM,4FAAN;;;;AAIA,UAAM,WAAW,KAAK,MAAL,CAAY,UAAC,KAAD;AAAA,eAAW,QAAQ,OAAK,CAAxB;AAAA,OAAZ,EACf,GADe,CACX,UAAC,KAAD;AAAA,eAAW,OAAK,CAAL,IAAU,QAAQ,CAAlB,CAAX;AAAA,OADW,CAAjB;AAEA,eAAS,IAAT,CAAc,CAAd;;AAEA,aAAO,QAAP;AACD;;;;;;kBAGY,a","file":"fibonacci-lfsr.js","sourcesContent":["import 'babel-polyfill'\nimport LFSR from './lfsr'\nimport population_count from './utilities/population-count'\n\n/**\n * A Fibonacci implementation of a linear feedback shift register (LFSR).\n * Feedback taps are ordered `1..m`.\n *\n * @param {number} m - Number of taps in the register.\n * @param {number[]} [feedback_taps=[1]] - Indices of taps that affect the\n *   output (range `1..m` inclusive).\n * @param {(number|string)} [seed=1] - Starting value for the generator.\n *\n * @augments LFSR\n * @throws {TypeError}\n *\n * @example <caption>A 3-tap m-sequence (maximum-length sequence)</caption>\n *   var size = 3\n *   var lfsr = new FibonacciLFSR(size, [size, 2])\n *   console.log(lfsr.current_state, lfsr.current_state.toString(2))\n *   //=> 1, \"1\"\n *\n *   for (var n = 1; n <= lfsr.maximum_sequence_length; n++) {\n *     var bit = lfsr.next()\n *\n *     console.log(lfsr.current_state, bit.toString(2))\n *   }\n *   //=> 4, \"0\"\n *   //=> 2, \"0\"\n *   //=> 5, \"1\"\n *   //=> 6, \"0\"\n *   //=> 7, \"1\"\n *   //=> 3, \"1\"\n *   //=> 1, \"1\"\n *\n * @see {GaloisLFSR}\n * @see https://en.wikipedia.org/wiki/Linear_feedback_shift_register\n * @see http://www.newwaveinstruments.com/resources/articles/m_sequence_linear_feedback_shift_register_lfsr.htm\n */\nclass FibonacciLFSR extends LFSR {\n  /**\n   * Generate the next state in the sequence.\n   *\n   * @returns {number} The output bit.\n   *\n   * @example <caption>How the next state is calculated</caption>\n   *   var lfsr = new FibonacciLFSR(3, [3, 1], 4)\n   *   var state = lfsr.current_state // 4\n   *   //=> 0b100\n   *   var active_tapped_bits = state & this.feedback_tap_mask\n   *   // = 0b100 & 0b101\n   *   // = 4\n   *   //=> 0b100\n   *   var active_bit_count = 0\n   *   for (; active_tapped_bits; active_bit_count++) {\n   *     active_tapped_bits &= active_tapped_bits - 1\n   *   }\n   *   var input_bit = active_bit_count % 2\n   *   // = 1 % 2\n   *   //=> 1\n   *   state >>= 1 // 2\n   *   //=> 0b010\n   *   state |= (input_bit << (this.m - 1))\n   *   // = 1 << (3 - 1)\n   *   //=> 110\n   *   state & 1 // 0\n   *   //=> 0\n   */\n  next() {\n    let state = this.current_state\n\n    // The input bit is the binary sum (XOR) of the feedback taps' values.\n    let active_tapped_bits = state & this.feedback_tap_mask\n    let active_bit_count = population_count(active_tapped_bits)\n    let input_bit = active_bit_count % 2\n\n    // Drop previous output bit.\n    state >>= 1\n    // Prepend the input bit.\n    //\n    // @note `-1` because the input bit takes up a slot.\n    state |= (input_bit << (this.m - 1))\n\n    this.current_state = state\n\n    return this.output_bit\n  }\n\n  /**\n   * Validate and process feedback tap indices.\n   *\n   * @type {number[]}\n   */\n  get sanitized_feedback_taps() {\n    const taps = super.sanitized_feedback_taps\n\n    // Fibonacci LFSRs always use the last tap (`tap_j = m`). It will be\n    // manually added in as part of setting the tap mask.\n    const adjusted = taps.filter((tap_j) => tap_j < this.m).\n      map((tap_j) => this.m - (tap_j - 1))\n    adjusted.push(1)\n\n    return adjusted\n  }\n}\n\nexport default FibonacciLFSR\n"]}
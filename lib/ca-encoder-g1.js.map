{"version":3,"sources":["../src/ca-encoder-g1.js"],"names":[],"mappings":";;;;;;;;;;AAAA;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IA4BM,W;;;;;;;AAIJ,yBAAc;AAAA;;AAAA,0FACN,EADM,EACF,CAAC,EAAD,EAAK,CAAL,CADE,EACO,IADP;AAEb;;;;;;;;;2BAKM;AACL;;AAEA,aAAO,KAAK,aAAL,GAAqB,CAA5B;AACD;;;;;;kBAEY,W","file":"ca-encoder-g1.js","sourcesContent":["import 'babel-polyfill'\nimport FibonacciLFSR from './fibonacci-lfsr'\n\n/**\n* Generates the *G1* {@linkcode LFSR} for the [C/A-Code]{@linkcode CAEncoder}\n* (coarse acquisition code) *G<sub>i</sub>* [Gold code]. The *G1* LFSR\n* operates like a normal LFSR, but its output is the value of tap 10, rather\n* than the standard binary sum of all active taps.\n*\n* [GPS specification]{@link http://www.gps.gov/technical/icwg/IS-GPS-200H.pdf}\n* (IS-GPS-200 revision H) ยง 3.3.2.3\n*\n* > The *G2<sub>i</sub>* sequence is formed by effectively delaying the *G2*\n* > sequence by an integer number of chips. The *G1* and *G2* sequences are\n* > generated by 10-stage shift registers having the following polynomials as\n* > referred to in the shift register input (see Figures 3-8 and 3-9).\n* >\n* > * G1 = X<sup>10</sup> + X<sup>3</sup> + 1, and\n* > * G2 = X<sup>10</sup> + X<sup>9</sup> + X<sup>8</sup> + X<sup>6</sup> + X<sup>3</sup> + X<sup>2</sup> + 1.\n* >\n* > The initialization vector for the *G1* and *G2* sequences is `1111111111`.\n* > The *G1* and *G2* shift registers are initialized at the P-coder *X1*\n* > epoch. The *G1* and *G2* registers are clocked at 1.023 MHz derived from\n* > the 10.23 MHz P-coder clock. [...]\n*\n* @augments FibonacciLFSR\n*\n* @see http://what-when-how.com/a-software-defined-gps-and-galileo-receiver/gps-signal-gps-and-galileo-receiver-part-2/\n */\nclass CAEncoderG1 extends FibonacciLFSR {\n  /**\n   * @throws {TypeError}\n   */\n  constructor() {\n    super(10, [10, 3], 0b1111111111)\n  }\n\n  /**\n   * @inheritdoc\n   */\n  next() {\n    super.next()\n\n    return this.current_state & 0b0000000001\n  }\n}\nexport default CAEncoderG1\n"]}
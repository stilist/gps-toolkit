{"version":3,"sources":["../src/galois-lfsr.js"],"names":[],"mappings":";;;;;;;;AAAA;;AACA;;;;;;;;;;;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAmCM,U;;;;;;;;;;;;AACJ;;;;;;;;;;;;;;;;;;;;;2BAqBO;AACL,UAAI,QAAQ,KAAK,aAAjB;AACA;AACA,UAAM,QAAQ,QAAQ,CAAtB;;AAEA;AACA;AACA,gBAAU,CAAV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAU,CAAC,KAAF,GAAW,KAAK,iBAAzB;AACA,WAAK,aAAL,GAAqB,KAArB;;AAEA,aAAO,KAAK,UAAZ;AACD;;;;;;kBAGY,U","file":"galois-lfsr.js","sourcesContent":["import 'babel-polyfill'\nimport LFSR from './lfsr'\n\n/**\n * A Galois implementation of a linear feedback shift register (LFSR). Feedback\n * taps are numbered `m..1`.\n *\n * @param {number} m - Number of taps in the register.\n * @param {number[]} [feedback_taps=[1]] - Indices of taps that affect the\n *   output (range `1..m` inclusive).\n * @param {(number|string)} [seed=1] - Starting value for the generator.\n *\n * @augments LFSR\n * @throws {TypeError}\n *\n * @example <caption>A 3-tap m-sequence (maximum-length sequence)</caption>\n *   var size = 3\n *   var lfsr = new GaloisLFSR(size, [3, 2])\n *   console.log(lfsr.current_state, lfsr.current_state.toString(2))\n *   //=> 1, \"1\"\n *\n *   for (var n = 1; n <= lfsr.maximum_sequence_length; n++) {\n *     var bit = lfsr.next()\n *\n *     console.log(lfsr.current_state, bit.toString(2))\n *   }\n *   //=> 6, \"0\"\n *   //=> 3, \"1\"\n *   //=> 7, \"1\"\n *   //=> 5, \"1\"\n *   //=> 4, \"0\"\n *   //=> 2, \"0\"\n *   //=> 1, \"1\"\n *\n * @see {FibonacciLFSR}\n * @see https://en.wikipedia.org/wiki/Linear_feedback_shift_register\n * @see http://www.newwaveinstruments.com/resources/articles/m_sequence_linear_feedback_shift_register_lfsr.htm\n */\nclass GaloisLFSR extends LFSR {\n  /**\n   * Generate the next state in the sequence.\n   *\n   * @returns {number} The output bit.\n   *\n   * @example <caption>How the next state is calculated</caption>\n   *   var lfsr = new GaloisLFSR(3, [3, 1], 6)\n   *   var state = lfsr.current_state // 6\n   *   //=> 0b110\n   *   var input = state & 1 // 0\n   *   //=> 0b0\n   *   state >>= 1 // 3\n   *   //=> 0b011\n   *   state ^= (-input) & lfsr.feedback_tap_mask\n   *   // = state ^= (0b11111111111111111111111111111111 & 0b101)\n   *   // = state ^= 0b110\n   *   // = 3\n   *   //=> 0b011\n   *   state & 1 // 1\n   *   //=> 0b1\n   */\n  next() {\n    let state = this.current_state\n    // Use the lowest bit in `state` as the input.\n    const input = state & 1\n\n    // Drop the current input bit so the lowest bit of the new state serves as\n    // the next input bit.\n    state >>= 1\n    // JavaScript represents numbers in two's complement format: `0` and `-0`\n    // are stored as `00000000`; `-1` is `11111111`. Because `input` is always\n    // `0` or `1`, `-input` is a convenient way to get a bitmask to `&` against\n    // when flipping bits for the next `state` value.\n    //\n    // @see https://en.wikipedia.org/w/index.php?title=Signed_number_representations&oldid=712932585#Two.27s_complement\n    state ^= (-input) & this.feedback_tap_mask\n    this.current_state = state\n\n    return this.output_bit\n  }\n}\n\nexport default GaloisLFSR\n"]}
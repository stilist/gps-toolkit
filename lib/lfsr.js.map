{"version":3,"sources":["../src/lfsr.js"],"names":[],"mappings":"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","file":"lfsr.js","sourcesContent":["import 'babel-polyfill'\nimport { bits_in_number } from './utilities/constants'\nimport { log_taps } from './utilities/debug'\n\n/**\n * Filter an array to unique items.\n *\n * @param {Array} array - The array to process.\n * @returns {Array} The unique items in `array`.\n *\n * @access private\n */\nfunction uniq(array) {\n  if (typeof array.length === 'undefined') return []\n\n  const seen = []\n  const unique = []\n\n  for (let item of array) {\n    if (seen.indexOf(item) === -1) unique.push(item)\n    seen.push(item)\n  }\n\n  return unique\n}\n\n/**\n * A base implementation of a linear feedback shift register (LFSR).\n *\n * @example <caption>Setting an integer seed</caption>\n *   var lfsr = new LFSR(3, [3, 2], 6)\n *   console.log(lfsr.current_state, lfsr.current_state.toString(2))\n *   //=> 6, \"110\"\n *\n * @example <caption>Setting a binary seed</caption>\n *   var lfsr = new LFSR(3, [3, 2], \"110\")\n *   console.log(lfsr.current_state, lfsr.current_state.toString(2))\n *   //=> 6, \"110\"\n *\n * @see https://en.wikipedia.org/wiki/Linear_feedback_shift_register\n * @see http://www.newwaveinstruments.com/resources/articles/m_sequence_linear_feedback_shift_register_lfsr.htm\n */\nclass LFSR {\n  /**\n   * @param {number} m - Number of taps in the register.\n   * @param {number[]} [feedback_taps=[1]] - Indices of taps that affect the\n   *   output (range `1..m` inclusive).\n   * @param {(number|string)} [seed=1] - Starting value for the generator.\n   *\n   * @throws {TypeError}\n   */\n  constructor(m = 1, feedback_taps = [1], seed = 1) {\n    if (typeof m !== 'number') throw new TypeError('m must be Number')\n\n    // Make sure the entire `m` sequence can be stored in a `Number` even if\n    // `feedback_taps` is configured to generate an m-sequence. (`2**53 - 1` =\n    // `Number.MAX_SAFE_INTEGER`.)\n    this.m = m\n    if (m < 1 || m > bits_in_number) {\n      throw new TypeError(`m must be in the range 1..${bits_in_number} (inclusive)`)\n    }\n\n    if (typeof feedback_taps.length === 'undefined') {\n      throw new TypeError('feedback_taps must be null or Array')\n    }\n    // Handle empty array.\n    if (!feedback_taps.length) feedback_taps = [1]\n    this.feedback_taps = feedback_taps\n\n    if (seed && typeof seed !== 'number' && typeof seed !== 'string') {\n      throw new TypeError('seed must be null, Number, or String')\n    }\n    this.provided_seed = seed\n    this.current_state = this.seed\n  }\n\n  /**\n   * The current output bit.\n   *\n   * @type {number}\n   */\n  get output_bit() {\n    return this.current_state & 0b1\n  }\n\n  /**\n   * Generate the next state in the sequence.\n   *\n   * @returns {number} The output bit.\n   * @throws {Error}\n   *\n   * @abstract\n   */\n  next() {\n    throw new Error('`next` must be implemented by subclasses')\n  }\n\n  /**\n   * LFSRs have a maximum of `2**m` states. One of those is fairly useless: if\n   * seeded with all `0`s, the LFSR will never transition to any other state.\n   * However, LFSR can never transition *into* that state either, so the LFSR\n   * can cycle through a maximum of `2**m - 1` states.\n   *\n   * @type {number}\n   *\n   * @todo Replace with `.length`. (See {@linkcode LFSR.sequence}.)\n   */\n  get maximum_sequence_length() {\n    if (this._maximum_sequence_length) return this._maximum_sequence_length\n\n    const max_length = Math.pow(2, this.m) - 1\n\n    this._maximum_sequence_length = max_length\n    return max_length\n  }\n\n  /**\n   * Validates the user's seed and sets a fallback value.\n   *\n   * @type {number}\n   */\n  get seed() {\n    if (this._seed) return this._seed\n\n    let bitstring = this.provided_seed\n\n    // Coerce numbers to bitstrings to simplify length sanitization.\n    if (typeof bitstring === 'number') bitstring = bitstring.toString(2)\n\n    // Ensure the seed is at most `m` bits long.\n    bitstring = bitstring.slice(-this.m)\n    // Convert back to a number.\n    const seed = parseInt(bitstring, 2)\n\n    this._seed = seed\n    return seed\n  }\n\n  /**\n   * Validate and process feedback tap indices.\n   *\n   * @type {number[]}\n   *\n   * @access protected\n   */\n  get sanitized_feedback_taps() {\n    if (this._sanitized_feedback_taps) return this._sanitized_feedback_taps\n\n    const taps = this.feedback_taps\n    const unique = uniq(taps)\n\n    // Reject any indices outside the range `1..m`.\n    const valid = unique.filter((tap_j) => tap_j > 0 && tap_j <= this.m)\n\n    this._sanitized_feedback_taps = valid\n    return valid\n  }\n\n  /**\n   * The complete LFSR sequence.\n   *\n   * @type {number}\n   *\n   * @todo Is there a way to calculate the length of non-maximal sequences\n   *   instead of watching for the state to repeat? (The current approach\n   *   has to call {@linkcode LFSR#next} an extra time, which goofs up the\n   *   internal state.)\n   */\n  get sequence() {\n    if (this._sequence) return this._sequence\n\n    const bits = [this.seed & 0b1]\n    for (let i = 0; ; i++) {\n      let bit = this.next()\n\n      if (this.current_state === this.seed) break\n      else bits.push(bit)\n    }\n\n    this._sequence = parseInt(bits.join(''), 2)\n\n    return this._sequence\n  }\n\n  /**\n   * Converts the list of tap indices into a corresponding bitmask.\n   *\n   * @type {number}\n   *\n   * @access private\n   *\n   * @example <caption>An example tap mask</caption>\n   *   var lfsr = new LFSR(3, [3, 2])\n   *   console.log(lfsr.feedback_tap_mask.toString(2))\n   *   //=> \"110\"\n   */\n  get feedback_tap_mask() {\n    if (this._feedback_tap_mask) return this._feedback_tap_mask\n\n    const taps = this.sanitized_feedback_taps\n\n    // `1 << tap_j - 1` makes a one followed by `tap_j - 1` zeroes; that value\n    // is then ORed with `mask`, which sets bit `tap_j - 1` of `mask` to `1`.\n    let mask = taps.reduce((memo, tap_j) => memo | (1 << tap_j - 1),\n                           0)\n\n    this._feedback_tap_mask = mask\n    return mask\n  }\n\n  /**\n   * Logs the taps and current state to help with debugging.\n   *\n   * @access protected\n   */\n  log_taps() {\n    log_taps(this.sanitized_feedback_taps, this.current_state, this.m)\n  }\n}\n\nexport default LFSR\n"]}
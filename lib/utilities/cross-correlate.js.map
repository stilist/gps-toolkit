{"version":3,"sources":["../../src/utilities/cross-correlate.js"],"names":[],"mappings":";;;;;;AAAA;;AACA;;;;;;;;;;;;;;;;;AAaA,SAAS,eAAT,CAAyB,QAAzB,EAAiD;AAAA,MAAd,QAAc,yDAAH,CAAG;;AAC/C,MAAI,CAAC,SAAS,MAAd,EAAsB,MAAM,IAAI,SAAJ,CAAc,2BAAd,CAAN;AACtB,MAAI,OAAO,QAAP,KAAoB,QAAxB,EAAkC,MAAM,IAAI,SAAJ,CAAc,2BAAd,CAAN;;AAElC,MAAM,OAAO,SAAS,KAAT,CAAe,CAAf,EAAkB,CAAC,QAAnB,CAAb;AACA,MAAM,OAAO,SAAS,KAAT,CAAe,SAAS,MAAT,GAAkB,QAAjC,CAAb;;AAEA,SAAO,KAAK,MAAL,CAAY,IAAZ,CAAP;AACD;;;;;;;;;;;;;;;;;;;;;;AAsBD,SAAS,eAAT,CAAyB,SAAzB,EAAoC,SAApC,EAA+C;AAC7C,MAAM,SAAS,KAAK,GAAL,CAAS,UAAU,QAAV,CAAmB,CAAnB,EAAsB,MAA/B,EACS,UAAU,QAAV,CAAmB,CAAnB,EAAsB,MAD/B,CAAf;;;AAIA,MAAI,QAAQ,EAAZ;;AAEA,OAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,MAApB,EAA4B,GAA5B;AAAiC,UAAM,SAAS,CAAf,IAAqB,aAAa,CAAd,GAAmB,CAAvC;AAAjC,GAEA,IAAI,eAAe,CAAC,0BAAY,SAAZ,EAAuB,SAAvB,EAAkC,MAAlC,CAAD,CAAnB;AACA,OAAK,IAAI,SAAS,CAAlB,EAAqB,SAAS,MAA9B,EAAsC,QAAtC,EAAgD;AAC9C,QAAI,UAAU,gBAAgB,KAAhB,EAAuB,MAAvB,CAAd;;AAEA,QAAI,WAAW,SAAS,QAAQ,IAAR,CAAa,EAAb,CAAT,EAA2B,CAA3B,CAAf;AACA,QAAI,cAAc,0BAAY,SAAZ,EAAuB,QAAvB,EAAiC,MAAjC,CAAlB;;AAEA,iBAAa,IAAb,CAAkB,WAAlB;AACD;;AAED,SAAO,YAAP;AACD;kBACc,e","file":"cross-correlate.js","sourcesContent":["import 'babel-polyfill'\nimport dot_product from './dot-product'\n\n/**\n * Rotate `distance` members to the head of `sequence`.\n *\n * @param {number[]} sequence - The array to rotate.\n * @param {number} [distance=1] - How many members to move.\n *\n * @access private\n * @throws {TypeError}\n *\n * @todo Handle `distance > sequence.length`.\n */\nfunction rotate_sequence(sequence, distance = 1) {\n  if (!sequence.length) throw new TypeError('sequence must be an Array')\n  if (typeof distance !== 'number') throw new TypeError('distance must be a Number')\n\n  const head = sequence.slice(0, -distance)\n  const tail = sequence.slice(sequence.length - distance)\n\n  return tail.concat(head)\n}\n\n/**\n * > In signal processing, cross-correlation is a measure of similarity of two\n * > series as a function of the lag of one relative to the other.\n * >\n * > [...]\n * >\n * > In an autocorrelation, which is the cross-correlation of a signal with\n * > itself, there will always be a peak at a lag of zero, and its size will be\n * > the signal power.\n *\n * @param {number} sequenceA - The reference sequence.\n * @param {number} sequenceB - The sequence to correlate.\n * @returns {number[]} The correlation at each offset of `sequenceB`.\n *\n * @example <caption>Correlating a sequence with itself (autocorrelation)</caption>\n *   cross_correlate(0b110010, 0b110010)\n *   //=> [6, -2, -2, 2, -2, -2]\n *\n * @see https://en.wikipedia.org/wiki/Cross-correlation\n */\nfunction cross_correlate(sequenceA, sequenceB) {\n  const length = Math.max(sequenceA.toString(2).length,\n                          sequenceB.toString(2).length)\n\n  // Map `sequenceB` into an `Array` so it can be rotated.\n  let bitsB = []\n  // @see http://stackoverflow.com/questions/14104208/convert-integer-to-binary-and-store-it-in-an-integer-array-of-specified-sizec#comment19514125_14104263\n  for (let i = 0; i < length; i++) bitsB[length - i] = (sequenceB >> i) & 0b1\n\n  let correlations = [dot_product(sequenceA, sequenceB, length)]\n  for (let offset = 1; offset < length; offset++) {\n    let rotated = rotate_sequence(bitsB, offset)\n\n    let sequence = parseInt(rotated.join(''), 2)\n    let correlation = dot_product(sequenceA, sequence, length)\n\n    correlations.push(correlation)\n  }\n\n  return correlations\n}\nexport default cross_correlate\n"]}
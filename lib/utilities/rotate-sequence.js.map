{"version":3,"sources":["../../src/utilities/rotate-sequence.js"],"names":[],"mappings":";;;;;QAmBgB,Y,GAAA,Y;QAgCA,kB,GAAA,kB;;AAnDhB;;AACA;;AACA;;;;;;;;;;;;;;;;;;;;;AAiBO,SAAS,YAAT,CAAsB,KAAtB,EAA2C;AAAA,MAAd,QAAc,yDAAH,CAAG;;AAChD,MAAI,CAAC,MAAM,OAAN,CAAc,KAAd,CAAL,EAA2B,MAAM,IAAI,SAAJ,CAAc,wBAAd,CAAN;AAC3B,MAAI,OAAO,QAAP,KAAoB,QAAxB,EAAkC,MAAM,IAAI,SAAJ,CAAc,2BAAd,CAAN;;AAElC,aAAW,KAAK,GAAL,CAAS,QAAT,CAAX;;AAEA,MAAI,CAAC,MAAM,MAAX,EAAmB,OAAO,KAAP;;AAEnB,MAAM,OAAO,MAAM,KAAN,CAAY,CAAZ,EAAe,CAAC,QAAhB,CAAb;AACA,MAAM,OAAO,MAAM,KAAN,CAAY,MAAM,MAAN,GAAe,QAA3B,CAAb;;AAEA,SAAO,KAAK,MAAL,CAAY,IAAZ,CAAP;AACD;;;;;;;;;;;;;;;;;;;;AAoBM,SAAS,kBAAT,CAA4B,IAA5B,EAA8E;AAAA,MAA5C,QAA4C,yDAAjC,CAAiC;AAAA,MAA9B,WAA8B;;AACnF,MAAI,OAAO,IAAP,KAAgB,QAApB,EAA8B,MAAM,IAAI,SAAJ,CAAc,uBAAd,CAAN;AAC9B,MAAI,OAAO,QAAP,KAAoB,QAAxB,EAAkC,MAAM,IAAI,SAAJ,CAAc,2BAAd,CAAN;AAClC,MAAI,OAAO,WAAP,KAAuB,QAA3B,EAAqC,MAAM,IAAI,SAAJ,CAAc,8BAAd,CAAN;;AAErC,aAAW,KAAK,GAAL,CAAS,QAAT,CAAX;;;;;;AAMA,MAAI,SAAS,CAAb,EAAgB,OAAO,IAAP;;AAEhB,MAAM,cAAc,KAAK,QAAL,CAAc,CAAd,CAApB;AACA,MAAI,QAAQ,uBAAS,WAAT,EAAsB,WAAtB,EAAmC,KAAnC,CAAyC,EAAzC,CAAZ;AACA,MAAI,UAAU,aAAa,KAAb,EAAoB,QAApB,EAA8B,IAA9B,CAAmC,EAAnC,CAAd;;AAEA,SAAO,SAAS,OAAT,EAAkB,CAAlB,CAAP;AACD","file":"rotate-sequence.js","sourcesContent":["import 'babel-polyfill'\nimport { bits_in_number } from './constants'\nimport pad_bits from './pad-bits'\n\n/**\n * Rotate `distance` elements to the head of `array`.\n *\n * @param {number[]} array - The array to rotate.\n * @param {number} [distance=1] - How many elements to move to the head.\n * @returns {Array} The rotated array.\n *\n * @throws {TypeError}\n *\n * @example <caption>Rotating with default length</caption>\n *   rotate_array([1, 2, 3])\n *   //=> [3, 1, 2]\n *\n * @todo Handle `distance > array.length`.\n */\nexport function rotate_array(array, distance = 1) {\n  if (!Array.isArray(array)) throw new TypeError('array must be an Array')\n  if (typeof distance !== 'number') throw new TypeError('distance must be a Number')\n\n  distance = Math.abs(distance)\n\n  if (!array.length) return array\n\n  const head = array.slice(0, -distance)\n  const tail = array.slice(array.length - distance)\n\n  return tail.concat(head)\n}\n\n/**\n * Rotate `distance` bits of a `Number` to the head of `bits`.\n *\n * @param {number} bits - The bits of this number will be rotated.\n * @param {number} [distance=1] - How many bits to move to the head.\n * @param {number} [bits_length=53] - The intended length of the bit sequence.\n *   Defaults to {@linkcode bits_in_number}.\n * @returns {number} The rotated `bits`. The return type matches the\n *   input type.\n *\n * @throws {TypeError}\n *\n * @example <caption>With default distance and bits_length</caption>\n *   rotate_number_bits(0b1)\n *   //=> parseInt('10000000000000000000000000000000000000000000000000000', 2)\n *\n * @todo Handle `distance > bits_length`.\n */\nexport function rotate_number_bits(bits, distance = 1, bits_length = bits_in_number) {\n  if (typeof bits !== 'number') throw new TypeError('bits must be a Number')\n  if (typeof distance !== 'number') throw new TypeError('distance must be a Number')\n  if (typeof bits_length !== 'number') throw new TypeError('bits_length must be a Number')\n\n  distance = Math.abs(distance)\n\n  /**\n   * (0).toString()\n   * //=> '0'\n   */\n  if (bits === 0) return bits\n\n  const bits_string = bits.toString(2)\n  let array = pad_bits(bits_string, bits_length).split('')\n  let rotated = rotate_array(array, distance).join('')\n\n  return parseInt(rotated, 2)\n}\n"]}
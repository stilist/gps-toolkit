<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: lfsr.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: lfsr.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import 'babel-polyfill'

/**
 * Filter an array to unique items.
 *
 * @param {Array} array - The array to process.
 * @returns {Array} The unique items in `array`.
 *
 * @access private
 */
function uniq(array) {
  if (typeof array.length === 'undefined') return []

  const seen = []
  const unique = []

  for (let item of array) {
    if (seen.indexOf(item) === -1) unique.push(item)
    seen.push(item)
  }

  return unique
}

/**
 * A base implementation of a linear feedback shift register (LFSR).
 *
 * @example &lt;caption>Setting an integer seed&lt;/caption>
 *   var lfsr = new LFSR(3, [3, 2], 6)
 *   console.log(lfsr.current_state, lfsr.current_state.toString(2))
 *   //=> 6, "110"
 *
 * @example &lt;caption>Setting a binary seed&lt;/caption>
 *   var lfsr = new LFSR(3, [3, 2], "110")
 *   console.log(lfsr.current_state, lfsr.current_state.toString(2))
 *   //=> 6, "110"
 *
 * @see https://en.wikipedia.org/wiki/Linear_feedback_shift_register
 * @see http://www.newwaveinstruments.com/resources/articles/m_sequence_linear_feedback_shift_register_lfsr.htm
 */
class LFSR {
  /**
   * @param {number} m - Number of taps in the register.
   * @param {number[]} [feedback_taps=[1]] - Indices of taps that affect the
   *   output (range `1..m` inclusive).
   * @param {(number|string)} [seed=1] - Starting value for the generator.
   *
   * @throws {TypeError}
   */
  constructor(m = 1, feedback_taps = [1], seed = 1) {
    if (typeof m !== 'number') throw new TypeError('m must be Number')

    // Make sure the entire `m` sequence can be stored in a `Number` even if
    // `feedback_taps` is configured to generate an m-sequence.
    this.m = m
    const max_m = Number.MAX_SAFE_INTEGER.
      toString(2).
      length
    if (m &lt; 1 || m > max_m) {
      throw new TypeError(`m must be in the range 1..${max_m} (inclusive)`)
    }

    if (typeof feedback_taps.length === 'undefined') {
      throw new TypeError('feedback_taps must be null or Array')
    }
    // Handle empty array.
    if (!feedback_taps.length) feedback_taps = [1]
    this.feedback_taps = feedback_taps

    if (seed &amp;&amp; typeof seed !== 'number' &amp;&amp; typeof seed !== 'string') {
      throw new TypeError('seed must be null, Number, or String')
    }
    this.provided_seed = seed
    this.current_state = this.seed
  }

  /**
   * Generate the next state in the sequence.
   *
   * @returns {number} The output bit.
   * @throws {Error}
   *
   * @abstract
   */
  next() {
    throw new Error('`next` must be implemented by subclasses')
  }

  /**
   * LFSRs have a maximum of `2**m` states. One of those is fairly useless: if
   * seeded with all `0`s, the LFSR will never transition to any other state.
   * However, LFSR can never transition *into* that state either, so the LFSR
   * can cycle through a maximum of `2**m - 1` states.
   *
   * @type {number}
   *
   * @todo Replace with `.length`. (See {@linkcode LFSR.sequence}.)
   */
  get maximum_sequence_length() {
    if (this._maximum_sequence_length) return this._maximum_sequence_length

    const max_length = Math.pow(2, this.m) - 1

    this._maximum_sequence_length = max_length
    return max_length
  }

  /**
   * Validates the user's seed and sets a fallback value.
   *
   * @type {number}
   */
  get seed() {
    if (this._seed) return this._seed

    let bitstring = this.provided_seed

    // Coerce numbers to bitstrings to simplify length sanitization.
    if (typeof bitstring === 'number') bitstring = bitstring.toString(2)

    // Ensure the seed is at most `m` bits long.
    bitstring = bitstring.slice(-this.m)
    // Convert back to a number.
    const seed = parseInt(bitstring, 2)

    this._seed = seed
    return seed
  }

  /**
   * Validate and process feedback tap indices.
   *
   * @type {number[]}
   *
   * @access protected
   */
  get sanitized_feedback_taps() {
    if (this._sanitized_feedback_taps) return this._sanitized_feedback_taps

    const taps = this.feedback_taps
    const unique = uniq(taps)

    // Reject any indices outside the range `1..m`.
    const valid = unique.filter((tap_j) => tap_j > 0 &amp;&amp; tap_j &lt;= this.m)

    this._sanitized_feedback_taps = valid
    return valid
  }

  /**
   * The complete LFSR sequence.
   *
   * @type {number}
   *
   * @todo Is there a way to calculate the length of non-maximal sequences
   *   instead of watching for the state to repeat? (The current approach
   *   has to call {@linkcode LFSR#next} an extra time, which goofs up the
   *   internal state.)
   */
  get sequence() {
    if (this._sequence) return this._sequence

    const bits = [this.seed &amp; 0b1]
    for (let i = 0; ; i++) {
      let bit = this.next()

      if (this.current_state === this.seed) break
      else bits.push(bit)
    }

    this._sequence = parseInt(bits.join(''), 2)

    return this._sequence
  }

  /**
   * Converts the list of tap indices into a corresponding bitmask.
   *
   * @type {number}
   *
   * @access private
   *
   * @example &lt;caption>An example tap mask&lt;/caption>
   *   var lfsr = new LFSR(3, [3, 2])
   *   console.log(lfsr.feedback_tap_mask.toString(2))
   *   //=> "110"
   */
  get feedback_tap_mask() {
    if (this._feedback_tap_mask) return this._feedback_tap_mask

    const taps = this.sanitized_feedback_taps

    // `1 &lt;&lt; tap_j - 1` makes a one followed by `tap_j - 1` zeroes; that value
    // is then ORed with `mask`, which sets bit `tap_j - 1` of `mask` to `1`.
    let mask = taps.reduce((memo, tap_j) => memo | (1 &lt;&lt; tap_j - 1),
                           0)

    this._feedback_tap_mask = mask
    return mask
  }
}

export default LFSR
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="FibonacciLFSR.html">FibonacciLFSR</a></li><li><a href="GaloisLFSR.html">GaloisLFSR</a></li><li><a href="GoldCode.html">GoldCode</a></li><li><a href="LFSR.html">LFSR</a></li><li><a href="MSequence.html">MSequence</a></li></ul><h3>Global</h3><ul><li><a href="global.html#bits_to_string">bits_to_string</a></li><li><a href="global.html#cross_correlate">cross_correlate</a></li><li><a href="global.html#dot_product">dot_product</a></li><li><a href="global.html#is_preferred_sequence">is_preferred_sequence</a></li><li><a href="global.html#population_count">population_count</a></li><li><a href="global.html#preferred_sequence_values">preferred_sequence_values</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Sat Jun 11 2016 17:09:47 GMT-0700 (PDT)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
